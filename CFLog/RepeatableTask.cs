//***************************************************************************
// Copyright (c) Takahiro Fukushima All rights reserved.
// Licensed under the MIT license.
//***************************************************************************

namespace CFLog
{
	//=======================================================================
	/// <summary>
	/// 見かけ上再スタートが可能な Task
	/// </summary>
	/// <remarks>
	/// Taskクラスは Run() で実行されたタスクが一度終了すると、再利用できない。
	/// そのため、再度 Task のインスタンスが新たに必要になる。インスタンスを再度
	/// 取得する瞬間の状態の管理が複雑になるため、本クラスに処理をまとめる。
	/// </remarks>
	//=======================================================================
	internal class RepeatableTask
	{
		//===================================================================
		// メンバ
		//===================================================================
		Task? _task;
		private object _lockObject = new object();

		//===================================================================
		// サービスメソッド、プロパティ
		//===================================================================

		//-------------------------------------------------------------------
		/// <summary>
		/// タスクの実行
		/// </summary>
		//-------------------------------------------------------------------
		public void Run(Action action)
		{
			_task?.Wait();		// 二重起動を避ける

			lock(_lockObject)
			{
				_task?.Dispose();	// 長期間使用時のハンドルリークを避けたい（Dispose()後にWait()しても問題ない）
				_task = Task.Run(action);
			}
		}

		//-------------------------------------------------------------------
		/// <summary>
		/// タスク実行中？
		/// </summary>
		//-------------------------------------------------------------------
		public bool IsRunning
		{
			get
			{
				lock(_lockObject)
				{
					return !(_task?.Wait(0) ?? true);
				}
			}
		}

		//-------------------------------------------------------------------
		/// <summary>
		/// タスク終了を待つ
		/// </summary>
		//-------------------------------------------------------------------
		public void Wait()
		{
			// Wait() 処理で長時間 lock されると、IsRunning がその間抜けられなくなるため
			// 以下のように対応している
			// ただし、ここでの lock はほぼ不要とも考えられる

			Task? task;
			lock (_lockObject)
			{
				task = _task;
			}

			task?.Wait();
		}
	}
}
